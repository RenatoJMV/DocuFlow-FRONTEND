// Cliente API para DocuFlow
// Maneja todas las peticiones HTTP con interceptores de autenticación y error

import { authService } from './authService.js';
import securityService from './securityService.js';

class ApiClient {
  constructor() {
    this.baseURL = this.getBaseURL();
    this.defaultHeaders = {
      'Content-Type': 'application/json',
      'Accept': 'application/json'
    };
    
    // Rate limiting y monitoreo
    this.requestCount = new Map();
    this.lastRequestTime = new Map();
    
    // Configurar interceptores
    this.setupInterceptors();
    this.setupSecurityInterceptors();
  }
import { store } from './store.js';
import { showNotification, showLoading } from '../utils/uiHelpers.js';

class ApiClient {
  constructor(baseUrl) {
    this.baseUrl = baseUrl || 'http://localhost:3000/api';
    this.offlineMode = false;
    this.interceptors = {
      request: [],
      response: [],
      error: []
    };
    
    // Configuración por defecto
    this.defaults = {
      timeout: 10000,
      headers: {
        'Content-Type': 'application/json'
      }
    };

    // Detectar si estamos en producción
    if (window.location.hostname !== 'localhost' && window.location.hostname !== '127.0.0.1') {
      this.baseUrl = 'https://your-render-app.onrender.com/api'; // Cambiar por tu URL de Render
    }
  }

  // Agregar interceptores
  addRequestInterceptor(fn) {
    this.interceptors.request.push(fn);
    return this;
  }

  addResponseInterceptor(fn) {
    this.interceptors.response.push(fn);
    return this;
  }

  addErrorInterceptor(fn) {
    this.interceptors.error.push(fn);
    return this;
  }

  // Método principal para hacer requests
  async request(endpoint, options = {}) {
    try {
      // Si ya estamos en modo offline, usar datos de demostración directamente
      if (this.offlineMode) {
        return await this.getDemoResponse(endpoint, options);
      }

      // Configurar request base
      let config = {
        method: options.method || 'GET',
        headers: {
          ...this.defaults.headers,
          ...options.headers
        },
        ...options
      };

      // Ejecutar interceptores de request
      for (const interceptor of this.interceptors.request) {
        config = await interceptor(config, endpoint);
      }

      // Mostrar loading si está habilitado
      if (options.showLoading !== false) {
        store.setLoading(true);
      }

      // Crear AbortController para timeout
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), this.defaults.timeout);

      config.signal = controller.signal;

      // Hacer el request
      const response = await fetch(`${this.baseUrl}${endpoint}`, config);
      clearTimeout(timeoutId);

      // Ejecutar interceptores de response
      let processedResponse = response;
      for (const interceptor of this.interceptors.response) {
        processedResponse = await interceptor(processedResponse, config, endpoint);
      }

      return await this.handleResponse(processedResponse, options);

    } catch (error) {
      // Si hay error de conexión, activar modo offline y usar datos demo
      if (error.name === 'AbortError' || error.message.includes('Failed to fetch') || 
          error.message.includes('ERR_CONNECTION_REFUSED') || error.message.includes('NetworkError')) {
        
        if (!this.offlineMode) {
          console.warn('🔌 Servidor no disponible, activando modo offline con datos de demostración');
          this.offlineMode = true;
          
          // Mostrar notificación de modo offline (opcional, se puede comentar)
          if (typeof showNotification === 'function') {
            showNotification('Modo offline activado - usando datos de demostración', 'warning', 3000);
          }
        }
        
        return await this.getDemoResponse(endpoint, options);
      }

      // Ejecutar interceptores de error para otros tipos de error
      for (const interceptor of this.interceptors.error) {
        error = await interceptor(error, endpoint, options);
      }

      throw error;

    } finally {
      // Ocultar loading
      if (options.showLoading !== false) {
        store.setLoading(false);
      }
    }
  }

  // Método para obtener respuestas de demostración cuando no hay servidor
  async getDemoResponse(endpoint, options = {}) {
    // Simular delay de red
    await new Promise(resolve => setTimeout(resolve, 300 + Math.random() * 200));

    const method = options.method || 'GET';
    
    // Datos de demostración por endpoint
    if (endpoint === '/auth/login') {
      const credentials = options.body ? JSON.parse(options.body) : {};
      const { username, password } = credentials;
      
      // Validar credenciales demo
      const demoUsers = {
        'admin@docuflow.com': { password: 'admin123', role: 'admin', name: 'Administrador' },
        'user@docuflow.com': { password: 'user123', role: 'user', name: 'Usuario Regular' },
        'guest@docuflow.com': { password: 'guest123', role: 'guest', name: 'Invitado' }
      };
      
      const user = demoUsers[username];
      if (user && user.password === password) {
        return {
          success: true,
          user: {
            id: Math.floor(Math.random() * 1000),
            username,
            name: user.name,
            role: user.role,
            email: username
          },
          token: `demo-token-${Date.now()}`,
          message: '¡Inicio de sesión exitoso!'
        };
      } else {
        throw new Error('Credenciales incorrectas');
      }
    }

    // Dashboard stats
    if (endpoint === '/dashboard/stats') {
      return {
        success: true,
        data: {
          totalFiles: 156,
          totalUsers: 23,
          totalComments: 89,
          downloadsToday: 45,
          documents: 156,
          processed: 142,
          pending: 12,
          errors: 2
        }
      };
    }

    // Dashboard activity
    if (endpoint === '/dashboard/activity') {
      return {
        success: true,
        data: [
          {
            id: 1,
            type: 'file_upload',
            file: 'Documento_Importante.pdf',
            action: 'Subida',
            user: 'Juan Pérez',
            timestamp: new Date(Date.now() - 10 * 60000).toISOString(),
            status: 'success'
          },
          {
            id: 2,
            type: 'comment_added',
            file: 'Presentación_Q4.pptx',
            action: 'Comentario',
            user: 'María García',
            timestamp: new Date(Date.now() - 25 * 60000).toISOString(),
            status: 'info'
          }
        ]
      };
    }

    // Files
    if (endpoint === '/files') {
      return {
        success: true,
        data: [
          {
            id: 1,
            name: 'Documento_Importante.pdf',
            size: 2048576,
            type: 'pdf',
            uploadedBy: 'Juan Pérez',
            uploadDate: new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString()
          }
        ]
      };
    }

    // Default success response for other endpoints
    return {
      success: true,
      data: [],
      message: 'Respuesta de demostración'
    };
  }

  // Procesar respuesta
  async handleResponse(response, options = {}) {
    const contentType = response.headers.get('content-type');
    let data;

    try {
      if (contentType && contentType.includes('application/json')) {
        data = await response.json();
      } else if (contentType && contentType.includes('text/')) {
        data = await response.text();
      } else {
        data = await response.blob();
      }
    } catch (parseError) {
      console.warn('Could not parse response:', parseError);
      data = null;
    }

    if (response.ok) {
      // Mostrar notificación de éxito si está configurada
      if (options.successMessage) {
        showNotification(options.successMessage, 'success');
      }

      return {
        success: true,
        data,
        status: response.status,
        headers: response.headers,
        response
      };
    } else {
      const error = new ApiError(
        data?.error || data?.message || `HTTP ${response.status}: ${response.statusText}`,
        response.status,
        data,
        response
      );

      // Mostrar notificación de error si está configurada
      if (options.showErrorNotification !== false) {
        const errorMessage = error.message || 'Error en la petición';
        showNotification(errorMessage, 'error');
      }

      throw error;
    }
  }

  // Métodos de conveniencia
  get(endpoint, options = {}) {
    return this.request(endpoint, { ...options, method: 'GET' });
  }

  post(endpoint, body, options = {}) {
    const config = { ...options, method: 'POST' };
    if (body) {
      if (body instanceof FormData) {
        // No establecer Content-Type para FormData (el browser lo hace automáticamente)
        delete config.headers['Content-Type'];
        config.body = body;
      } else {
        config.body = JSON.stringify(body);
      }
    }
    return this.request(endpoint, config);
  }

  put(endpoint, body, options = {}) {
    const config = { ...options, method: 'PUT' };
    if (body) {
      if (body instanceof FormData) {
        delete config.headers['Content-Type'];
        config.body = body;
      } else {
        config.body = JSON.stringify(body);
      }
    }
    return this.request(endpoint, config);
  }

  patch(endpoint, body, options = {}) {
    const config = { ...options, method: 'PATCH' };
    if (body) {
      config.body = JSON.stringify(body);
    }
    return this.request(endpoint, config);
  }

  delete(endpoint, options = {}) {
    return this.request(endpoint, { ...options, method: 'DELETE' });
  }

  // Subida de archivos con progreso
  async upload(endpoint, file, options = {}) {
    return new Promise((resolve, reject) => {
      const xhr = new XMLHttpRequest();
      const formData = new FormData();
      
      formData.append('file', file);
      
      // Agregar campos adicionales
      if (options.fields) {
        Object.entries(options.fields).forEach(([key, value]) => {
          formData.append(key, value);
        });
      }

      // Configurar eventos
      xhr.upload.onprogress = (event) => {
        if (event.lengthComputable && options.onProgress) {
          const percentComplete = (event.loaded / event.total) * 100;
          options.onProgress(percentComplete, event);
        }
      };

      xhr.onload = () => {
        if (xhr.status >= 200 && xhr.status < 300) {
          try {
            const data = JSON.parse(xhr.responseText);
            resolve({
              success: true,
              data,
              status: xhr.status
            });
          } catch (error) {
            resolve({
              success: true,
              data: xhr.responseText,
              status: xhr.status
            });
          }
        } else {
          reject(new ApiError(
            `Upload failed: ${xhr.statusText}`,
            xhr.status,
            xhr.responseText
          ));
        }
      };

      xhr.onerror = () => {
        reject(new ApiError('Network error during upload', 0));
      };

      xhr.ontimeout = () => {
        reject(new ApiError('Upload timeout', 0));
      };

      // Configurar request
      xhr.open('POST', `${this.baseUrl}${endpoint}`);
      
      // Agregar headers de autenticación
      const token = localStorage.getItem('token');
      if (token) {
        xhr.setRequestHeader('Authorization', `Bearer ${token}`);
      }

      xhr.timeout = options.timeout || 30000;
      xhr.send(formData);
    });
  }

  // Descarga de archivos
  async download(endpoint, options = {}) {
    try {
      const response = await this.request(endpoint, {
        ...options,
        showLoading: options.showLoading !== false
      });

      if (response.success) {
        const blob = response.data instanceof Blob ? response.data : new Blob([response.data]);
        
        // Crear URL temporal para descarga
        const url = window.URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        
        // Intentar obtener el nombre del archivo desde los headers
        const disposition = response.headers.get('content-disposition');
        let filename = options.filename || 'download';
        
        if (disposition && disposition.includes('filename=')) {
          const matches = disposition.match(/filename[^;=\n]*=((['"]).*?\2|[^;\n]*)/);
          if (matches && matches[1]) {
            filename = matches[1].replace(/['"]/g, '');
          }
        }
        
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        
        // Limpiar URL temporal
        window.URL.revokeObjectURL(url);
        
        if (options.successMessage) {
          showNotification(options.successMessage, 'success');
        }
      }
    } catch (error) {
      console.error('Download error:', error);
      if (options.showErrorNotification !== false) {
        showNotification('Error al descargar el archivo', 'error');
      }
      throw error;
    }
  }

  // Configurar timeout
  setTimeout(timeout) {
    this.defaults.timeout = timeout;
    return this;
  }

  // Configurar headers por defecto
  setDefaultHeaders(headers) {
    this.defaults.headers = { ...this.defaults.headers, ...headers };
    return this;
  }

  // Configurar base URL
  setBaseUrl(baseUrl) {
    this.baseUrl = baseUrl;
    return this;
  }
}

// Clase de error personalizada
class ApiError extends Error {
  constructor(message, status = 0, data = null, response = null) {
    super(message);
    this.name = 'ApiError';
    this.status = status;
    this.data = data;
    this.response = response;
  }

  get isNetworkError() {
    return this.status === 0;
  }

  get isClientError() {
    return this.status >= 400 && this.status < 500;
  }

  get isServerError() {
    return this.status >= 500;
  }

  get isAuthError() {
    return this.status === 401 || this.status === 403;
  }
}

// Crear instancia del cliente API
const apiClient = new ApiClient();

// Interceptor de autenticación
apiClient.addRequestInterceptor((config, endpoint) => {
  const token = localStorage.getItem('token');
  if (token && !config.headers['Authorization']) {
    config.headers['Authorization'] = `Bearer ${token}`;
  }
  return config;
});

// Interceptor para manejar respuestas de autenticación
apiClient.addResponseInterceptor((response, config, endpoint) => {
  // Si recibimos un nuevo token en los headers, guardarlo
  const newToken = response.headers.get('x-new-token');
  if (newToken) {
    localStorage.setItem('token', newToken);
  }
  return response;
});

// Interceptor para manejar errores de autenticación
apiClient.addErrorInterceptor((error, endpoint, options) => {
  if (error.isAuthError && !endpoint.includes('/auth/')) {
    // Token expirado o inválido
    localStorage.removeItem('token');
    store.logout();
    
    // Redirigir al login solo si no estamos ya ahí
    if (!window.location.pathname.includes('login.html')) {
      showNotification('Sesión expirada. Por favor, inicia sesión nuevamente.', 'warning');
      setTimeout(() => {
        window.location.href = '../auth/login.html';
      }, 1500);
    }
  }
  
  // Almacenar error en el store
  store.setError(error);
  
  return error;
});

// Interceptor para logging en desarrollo
if (window.location.hostname === 'localhost' || window.location.search.includes('debug=true')) {
  apiClient.addRequestInterceptor((config, endpoint) => {
    console.log(`🚀 API Request: ${config.method} ${endpoint}`, config);
    return config;
  });

  apiClient.addResponseInterceptor((response, config, endpoint) => {
    console.log(`✅ API Response: ${config.method} ${endpoint}`, {
      status: response.status,
      headers: response.headers,
      response
    });
    return response;
  });

  apiClient.addErrorInterceptor((error, endpoint, options) => {
    console.error(`❌ API Error: ${endpoint}`, error);
    return error;
  });
}

// Métodos específicos para la API de DocuFlow
export const docuFlowAPI = {
  // Autenticación
  auth: {
    login: (credentials) => apiClient.post('/auth/login', credentials, {
      successMessage: '¡Bienvenido de vuelta!',
      showErrorNotification: true
    }),
    register: (userData) => apiClient.post('/auth/register', userData, {
      successMessage: 'Cuenta creada exitosamente',
      showErrorNotification: true
    }),
    logout: () => apiClient.post('/auth/logout', {}, {
      showLoading: false,
      showErrorNotification: false
    }),
    refreshToken: () => apiClient.post('/auth/refresh', {}, {
      showLoading: false,
      showErrorNotification: false
    })
  },

  // Archivos
  files: {
    getAll: () => apiClient.get('/files'),
    getById: (id) => apiClient.get(`/files/${id}`),
    upload: (file, metadata = {}) => apiClient.upload('/files/upload', file, {
      fields: metadata,
      onProgress: (percent) => {
        console.log(`Upload progress: ${percent.toFixed(1)}%`);
      },
      successMessage: 'Archivo subido exitosamente'
    }),
    download: (id, filename) => apiClient.download(`/files/${id}/download`, {
      filename,
      successMessage: 'Descarga iniciada'
    }),
    delete: (id) => apiClient.delete(`/files/${id}`, {
      successMessage: 'Archivo eliminado exitosamente'
    })
  },

  // Comentarios
  comments: {
    getAll: () => apiClient.get('/comments'),
    getByFileId: (fileId) => apiClient.get(`/comments/file/${fileId}`),
    create: (comment) => apiClient.post('/comments', comment, {
      successMessage: 'Comentario agregado'
    }),
    update: (id, comment) => apiClient.put(`/comments/${id}`, comment),
    delete: (id) => apiClient.delete(`/comments/${id}`, {
      successMessage: 'Comentario eliminado'
    })
  },

  // Dashboard
  dashboard: {
    getStats: () => apiClient.get('/dashboard/stats'),
    getRecentActivity: () => apiClient.get('/dashboard/activity')
  },

  // Permisos
  permissions: {
    getAll: () => apiClient.get('/permissions'),
    update: (userId, permissions) => apiClient.put(`/permissions/${userId}`, permissions, {
      successMessage: 'Permisos actualizados'
    })
  },

  // Logs
  logs: {
    getAll: (params = {}) => {
      const queryString = new URLSearchParams(params).toString();
      return apiClient.get(`/logs${queryString ? `?${queryString}` : ''}`);
    }
  },

  // Google Cloud Storage
  gcs: {
    getStats: () => apiClient.get('/gcs/stats', {
      showErrorNotification: false
    }),
    getOrphanedFiles: () => apiClient.get('/gcs/orphaned-files'),
    cleanupOrphaned: (fileIds) => apiClient.post('/gcs/cleanup-orphaned', { fileIds }, {
      successMessage: 'Archivos huérfanos limpiados exitosamente'
    }),
    getBucketInfo: () => apiClient.get('/gcs/bucket-info'),
    getStorageMetrics: () => apiClient.get('/gcs/metrics')
  },

  // Perfil de Usuario
  profile: {
    getCurrent: () => apiClient.get('/profile/current'),
    update: (profileData) => apiClient.put('/profile/current', profileData, {
      successMessage: 'Perfil actualizado exitosamente'
    }),
    uploadAvatar: (file) => apiClient.upload('/profile/avatar', file, {
      successMessage: 'Avatar actualizado exitosamente'
    }),
    removeAvatar: () => apiClient.delete('/profile/avatar', {
      successMessage: 'Avatar removido exitosamente'
    }),
    getActivity: (params = {}) => {
      const queryString = new URLSearchParams(params).toString();
      return apiClient.get(`/profile/activity${queryString ? `?${queryString}` : ''}`);
    },
    getPreferences: () => apiClient.get('/profile/preferences'),
    updatePreferences: (preferences) => apiClient.put('/profile/preferences', preferences, {
      successMessage: 'Preferencias actualizadas exitosamente'
    }),
    changePassword: (passwordData) => apiClient.put('/profile/password', passwordData, {
      successMessage: 'Contraseña cambiada exitosamente'
    }),
    deleteAccount: (confirmation) => apiClient.delete('/profile/account', {
      body: { confirmation },
      successMessage: 'Cuenta eliminada exitosamente'
    }),
    getStats: () => apiClient.get('/profile/stats'),
    getSessions: () => apiClient.get('/profile/sessions'),
    revokeSession: (sessionId) => apiClient.delete(`/profile/sessions/${sessionId}`, {
      successMessage: 'Sesión revocada exitosamente'
    })
  },

  // Sistema de Exportación
  export: {
    generatePdf: (type, options = {}) => apiClient.post('/export/pdf', { type, options }, {
      showLoading: true,
      successMessage: 'PDF generado exitosamente'
    }),
    generateExcel: (type, options = {}) => apiClient.post('/export/excel', { type, options }, {
      showLoading: true,
      successMessage: 'Excel generado exitosamente'
    }),
    generateCsv: (type, options = {}) => apiClient.post('/export/csv', { type, options }, {
      showLoading: true,
      successMessage: 'CSV generado exitosamente'
    }),
    downloadReport: (reportId, format) => apiClient.download(`/export/download/${reportId}`, {
      filename: `reporte_${reportId}.${format}`,
      successMessage: 'Descarga iniciada'
    }),
    getReportStatus: (reportId) => apiClient.get(`/export/status/${reportId}`),
    getAvailableTemplates: (type) => apiClient.get(`/export/templates/${type}`),
    createCustomTemplate: (templateData) => apiClient.post('/export/templates', templateData, {
      successMessage: 'Plantilla creada exitosamente'
    }),
    getExportHistory: (params = {}) => {
      const queryString = new URLSearchParams(params).toString();
      return apiClient.get(`/export/history${queryString ? `?${queryString}` : ''}`);
    },
    deleteReport: (reportId) => apiClient.delete(`/export/reports/${reportId}`, {
      successMessage: 'Reporte eliminado exitosamente'
    }),
    getReportPreview: (type, options = {}) => apiClient.post('/export/preview', { type, options }),
    scheduleReport: (scheduleData) => apiClient.post('/export/schedule', scheduleData, {
      successMessage: 'Reporte programado exitosamente'
    }),
    getScheduledReports: () => apiClient.get('/export/scheduled'),
    cancelScheduledReport: (scheduleId) => apiClient.delete(`/export/scheduled/${scheduleId}`, {
      successMessage: 'Reporte programado cancelado'
    })
  }
};

export { ApiClient, ApiError, apiClient };
export default apiClient;